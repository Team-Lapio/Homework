# 1. 레지스터란



- 레지스터는 CPU가 요청을 처리하는데 필요한 데이터를 일시적으로 저장하는 기억 장치이다.

  

- 실제로 컴퓨터에서 데이터를 영구적으로 저장하기 위해서는 하드디스크를 이용해야하고,  임시적으로 저장하는 장소를 메모리(RAM) 이라고 한다.

  

- 명령을 처리하기 위해서는 이들에 대한 주소와 명령의 종류를 저장할 수 있는 기억공간이 하나 더 필요하다. 바로 이런 역할을 하는 것이 CPU옆에 붙어있는 레지스터이다.



- 레지스터는 공간은 작지만 CPU와 직접 연결되어 있으므로 연산 속도가 메모라보다 실제 수십 배에서 수백 배까지 빠르다.



- CPU는 자체적으로 데이터를 저장할 방법이 없기 때문에 메모리로 직접 데이터를 전송할 수 없다.

  

- 연산을 위해서는 반드시 레지스터를 거쳐야 하며, 이를 위해서 레지스터는 특정 주소를 가리키거나 값을 읽어올 수 있다.

## 

# 2. 범용 레지스터

- 작은 데이터의 임시 저장 공간

- 연산처리 및 번지지정을 도와준다.

- 컴퓨터의 장치들을 제어한다.

  

### 데이터의 단위

최초 16 비트 시스템에서는 0 ~  15 비트까지 레지스터 공간을 제공했었다.

여기서 레지스터는 CPU당 한개만 존재하는 것이 아니며, 필요와 용도에 따라 여러 종휴가 있었으며,

각 레지스터의 사용 방식에 따라 이름을 구분하여 사용했다.



### 범용 레지스터의 종류

① EAX (Extended Accumulator Register)

![EAX](http://postfiles9.naver.net/20130408_248/67sooon_1365428049818Ge5Kq_PNG/040813_1332_E2.png?type=w2)

첫번째로 EAX라는 레지스터입니다.

이 EAX 레지스터는 산술(덧셈, 곱셈, 나눗셈 등등), 논리 연산을 수행할때 사용되면 함수의 반환값이 이 레지스터에 저장됩니다.

32Bit로 구성되어 있으며, EAX를 반으로 쪼개면 AX(16Bit)가 됩니다.

또 다시 AX를 반으로 쪼개면 AH, AL로 나뉘고 각자 8Bit를 가지게 됩니다.



② EBX (Extended Base Register)

![EBX](http://postfiles10.naver.net/20130408_121/67sooon_1365428050079hjoJA_PNG/040813_1332_E3.png?type=w2)

두번째로는 EBX레지스터 입니다.

이 EBX레지스터는 메모리 주소를 저장하기 위한 용도로 사용됩니다.

다른 레지스터들과 마찬가지로 32bit로 구성되어 있으며, EBX를 반으로 쪼개면 BX(16bit)가 됩니다.

그 BX를 또 반으로 쪼개면 BH, BL로 나뉘고 각자 8bit를 가지게 됩니다.



③  ECX (Extended Counter Register)

![ECX](http://postfiles5.naver.net/20130408_68/67sooon_1365428050477OyRTU_PNG/040813_1332_E4.png?type=w2)

세번재로는 ECX 레지스터 입니다.

이 ECX레지스터는 반복 명령어(for, while 등) 명령어 사용시 반복 카운터로 사용되는 레지스터입니다.

ECX 레지스터에 반복할 횟수를 지정하고 반복 작업을 수행할때 쓰입니다.



④ EDX (Extended Data Register)

![EDX](http://postfiles14.naver.net/20130408_45/67sooon_1365428050673lP2wG_PNG/040813_1332_E5.png?type=w2)

이 EDX레지스터는 EAX레지스터와 같이쓰이고 부호 확장 명령 등에 쓰이고 큰수의 곱셈 또는 나눗셈 등의 연산이 이루어질때 EDX 레지스터가 사용됩니다.

32bit로 구성되어 있고 EDX를 반으로 쪼개면 DX(16bit)가 됩니다.

DX를 또 쪼개면 DH(4bit), DL(4bit)가 됩니다.



⑤ ESI (Extended Source) / ⑥ EDI (Destination Index)

![ESI / EDI](http://postfiles11.naver.net/20130408_170/67sooon_1365428050917YEcDt_PNG/040813_1332_E6.png?type=w2)

ESI는 데이터를 조작하거나, 복사할때 데이터의 주소가 저장됩니다.

EDI는 복사할때 목적지의 주소가 저장됩니다.



⑦ ESP (Extended Stack) / ⑧ EBP (Extended Base Pointer)

![ESP / EBP](http://postfiles2.naver.net/20130408_209/67sooon_1365428051182rl7S0_PNG/040813_1332_E7.png?type=w2)

ESP는 Stack의 끝 지점 주소를 가르키고, EBP는 Stack의 첫 시작 주소를 가르킵니다.



# 3. 메모리 구조

프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 로드(load)되어야 합니다.

또한, 프로그램에서 사용되는 변수들을 저장할 메모리도 필요합니다.

 

따라서 컴퓨터의 운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공하고 있습니다.

프로그램이 운영체제로부터 할당받는 대표적인 메모리 공간은 다음과 같습니다.



1. 코드(code) 영역

2. 데이터(data) 영역

3. 스택(stack) 영역

4. 힙(heap) 영역

   

다음 그림은 운영체제가 제공하는 메모리 공간을 표현하고 있습니다.



![메모리 공간](http://tcpschool.com/lectures/img_c_memory_structure.png)



---

### 코드(code) 영역

메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부릅니다.

CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.

---

### 데이터(data) 영역

메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다.

데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.



초기화 된 데이터는 data 영역에 저장되고,

초기화 되지 않은 데이터는 BSS (Block Stated Symbol) 영역에 저장된다.

---

### 스택(stack) 영역

메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.

스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다.

이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다.



스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.

이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.

스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.

---

### 힙(heap) 영역

메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 '그리고 해야만 하는' 메모리 영역입니다.

힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.

힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.

 

메모리의 동적 할당에 대한 더 자세한 사항은 C언어 메모리의 동적 할당 수업에서 확인할 수 있습니다.

---

# 4. 세그먼트 레지스터

  세그먼트 레지스터들은 메모리 세그먼트를 식별 할 수 있게 한다.

 레지스터의 크기는 16비트로 구성되어 있으며, FS와 GS레지스터가 추가 되어 한번에 6개의 서로 다른 세그먼트가 활성화 될 수 있다.

![img](https://t1.daumcdn.net/cfile/tistory/0353CE4D5153114B22)

### CS(Code Segment) 레지스터

실행될 명령어가 저장되어 있는 세그먼트의 시작 주소를 담고 있다.

---

### DS(Data Segment), ES(Extra Segment), FS, GS 레지스터

4개 데이터 세그먼트를 가리킨다. 4개의 데이터 세그먼트는 서로 다른 데이터 타입을 이루어져 안정하고 효율적인 접근을 허가한다.

---

### SS(Stack Segment) 

스택 세그먼트의 사작 위치(top)를 가리킨다.

---

# 5. flags 레지스터

32비트 

FLAGS레지스터는 여러 상태 플래그(State Flag)와 시스템 플래그(System Flag), 제어 플래그(Control Flag)로 구성된다.

![img](https://t1.daumcdn.net/cfile/tistory/0148E64F515314F22F)

위 그림은 각각의 플래그를 정의하고 있다. 프로세스가 초기화 된 이후 EFLAGS 레지스터의 상태는 00000002h가 된다. 회색 부분은 예약된 비트. 

상태 플래그 : EFLAGS 레지스터의 상태 플래그(0, 2, 4, 6, 7, 11번째 비트)는 ADD, SUB, MUL, DIV와 같은 산술 연산의 결과를 가리킨다.

---

### 상태 레지스터

- - OF(Overflow Flag) : 산술연산 결과의 오버플로우 상태를 표시한다.
  - DF(Direction Flag) : 스트링 처리시 오른쪽-왼쪽 or 왼쪽-오른쪽 처럼 처리 방향을 조절하는 플래그.
  - IF(Interrupt-enable Flag) : 외부 인터럽트 가능(enable) 또는 불가능(disable)을 나타낸다.
  - TF(Trap Flag) : 프로세서를 프로그램 디버그용의 싱글 스텝모드가 가능하도록 세팅한다.
  - SF(Sign Flag) : 연산 결과의, 최상위 비트가 1일 때 1로 세트된다. 즉, 최상위 비트가 1이면 음수, 0이면 양수를 나타낸다.
  - ZF(Zero Falg) : 연산 결과가 0으로 되었을 때 1로 세팅된다.
  - AF(Auxiliary Carry Flag) : 10진 산술 연산(BCD) 명령에 사용하고, 하위 니블(4비트)에서 상위 니블로의 자리올림 또는 상위에서 하위로 자리내림이 있을 때 1로 세팅된다.
  - PF(Parity Flag) : 오퍼레이션 결과의 최하위 바이트가 짝수 패리티인 경우에 세트되고, 홀수의 경우는 클리어(0이 됨)된다. 데이터 전송시 에러 검출에 사용한다.
  - CF(Carry Flag) : 최상위 비트에 자리올림 또는 내림이 발생하면 1로 세팅된다. or 부호 없는 정수에 대한 오버플로우를 나타낸다.

---





- 

- 















